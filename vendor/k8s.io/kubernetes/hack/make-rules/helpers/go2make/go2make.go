package main

import (
	"bytes"
	goflag "flag"
	"fmt"
	goformat "fmt"
	"github.com/spf13/pflag"
	"go/build"
	"io"
	"os"
	goos "os"
	godefaultruntime "runtime"
	"sort"
	"strings"
	gotime "time"
)

var flPrune = pflag.StringSlice("prune", nil, "sub-packages to prune (recursive, may be specified multiple times)")
var flDebug = pflag.BoolP("debug", "d", false, "enable debugging output")
var flHelp = pflag.BoolP("help", "h", false, "print help and exit")

func main() {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)
	pflag.Usage = func() {
		help(os.Stderr)
	}
	pflag.Parse()
	debug("PWD", getwd())
	build.Default.BuildTags = []string{"ignore_autogenerated"}
	build.Default.UseAllFiles = false
	if *flHelp {
		help(os.Stdout)
		os.Exit(0)
	}
	if len(pflag.Args()) == 0 {
		help(os.Stderr)
		os.Exit(1)
	}
	for _, in := range pflag.Args() {
		if strings.HasSuffix(in, "/...") {
			debug("starting", in)
			pkgName := strings.TrimSuffix(in, "/...")
			if err := WalkPkg(pkgName, visitPkg); err != nil {
				fmt.Fprintln(os.Stderr, err)
				os.Exit(1)
			}
		} else {
			if err := saveImport(in); err != nil {
				fmt.Fprintln(os.Stderr, err)
				os.Exit(2)
			}
		}
	}
}
func help(out io.Writer) {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	fmt.Fprintf(out, "Usage: %s [FLAG...] <PKG...>\n", os.Args[0])
	fmt.Fprintf(out, "\n")
	fmt.Fprintf(out, "go2make calculates all of the dependencies of a set of Go packages and prints\n")
	fmt.Fprintf(out, "them as variable definitions suitable for use as a Makefile.\n")
	fmt.Fprintf(out, "\n")
	fmt.Fprintf(out, "Package specifications may be simple (e.g. 'example.com/txt/color') or\n")
	fmt.Fprintf(out, "recursive (e.g. 'example.com/txt/...')\n")
	fmt.Fprintf(out, " Example:\n")
	fmt.Fprintf(out, "  $ %s ./example.com/pretty\n", os.Args[0])
	fmt.Fprintf(out, "  example.com/txt/split := \\\n")
	fmt.Fprintf(out, "    /go/src/example.com/txt/split/ \\\n")
	fmt.Fprintf(out, "    /go/src/example.com/txt/split/split.go \\\n")
	fmt.Fprintf(out, "  ./example.com/pretty := \\\n")
	fmt.Fprintf(out, "    /go/src/example.com/pretty/ \\\n")
	fmt.Fprintf(out, "    /go/src/example.com/pretty/print.go \\\n")
	fmt.Fprintf(out, "    /go/src/example.com/txt/split/ \\\n")
	fmt.Fprintf(out, "    /go/src/example.com/txt/split/split.go\n")
	fmt.Fprintf(out, "\n")
	fmt.Fprintf(out, " Flags:\n")
	pflag.PrintDefaults()
}
func debug(items ...interface{}) {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	if *flDebug {
		x := []interface{}{"DBG:"}
		x = append(x, items...)
		fmt.Println(x...)
	}
}
func visitPkg(importPath, absPath string) error {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	debug("visit", importPath)
	return saveImport(importPath)
}
func prune(pkgName string) bool {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	for _, pr := range *flPrune {
		if pr == pkgName {
			return true
		}
	}
	return false
}

var cache = map[string]*build.Package{}

func saveImport(pkgName string) error {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	if cache[pkgName] != nil {
		return nil
	}
	if prune(pkgName) {
		debug("prune", pkgName)
		return ErrSkipPkg
	}
	pkg, err := loadPackage(pkgName)
	if err != nil {
		return err
	}
	debug("save", pkgName)
	cache[pkgName] = pkg
	debug("recurse", pkgName)
	defer func() {
		debug("done   ", pkgName)
	}()
	if !pkg.Goroot && (len(pkg.GoFiles)+len(pkg.Imports) > 0) {
		for _, impName := range pkg.Imports {
			if impName == "C" {
				continue
			}
			debug("depends on", impName)
			saveImport(impName)
		}
		var buf bytes.Buffer
		buf.WriteString(pkgName)
		buf.WriteString(" := ")
		all := map[string]struct{}{}
		all[pkg.Dir+"/"] = struct{}{}
		filesForPkg(pkg, all)
		for _, imp := range pkg.Imports {
			pkg := cache[imp]
			if pkg == nil || pkg.Goroot {
				continue
			}
			all[pkg.Dir+"/"] = struct{}{}
			filesForPkg(pkg, all)
		}
		files := flatten(all)
		for _, f := range files {
			buf.WriteString(" \\\n  ")
			buf.WriteString(f)
		}
		fmt.Println(buf.String())
	}
	return nil
}
func filesForPkg(pkg *build.Package, all map[string]struct{}) {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	for _, file := range pkg.GoFiles {
		if pkg.Dir != "." {
			file = pkg.Dir + "/" + file
		}
		all[file] = struct{}{}
	}
}
func flatten(all map[string]struct{}) []string {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	list := make([]string, 0, len(all))
	for k := range all {
		list = append(list, k)
	}
	sort.Strings(list)
	return list
}
func loadPackage(pkgName string) (*build.Package, error) {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	debug("load", pkgName)
	pkg, err := build.Import(pkgName, getwd(), 0)
	if err != nil {
		if _, ok := err.(*build.NoGoError); !ok {
			return nil, err
		}
	}
	return pkg, nil
}
func getwd() string {
	_logClusterCodePath("Entered function: ")
	defer _logClusterCodePath("Exited function: ")
	pwd, err := os.Getwd()
	if err != nil {
		panic(fmt.Sprintf("can't get working directory: %v", err))
	}
	return pwd
}
func _logClusterCodePath(op string) {
	pc, _, _, _ := godefaultruntime.Caller(1)
	goformat.Fprintf(goos.Stderr, "[%v][ANALYTICS] %s%s\n", gotime.Now().UTC(), op, godefaultruntime.FuncForPC(pc).Name())
}
